/*
 * File generated by SourceCombiner using 24 source files.
 * Created On: 03/03/2018 12:01:12
*/
using Core;
using Core.Actors;
using Core.Factories;
using Core.Fights;
using Core.IA;
using Core.Interactives;
using Core.Items;
using Core.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
namespace Core
{
    public class GameEngine
    {
        FightManager fightManager = new FightManager();
        public List<Bush> Bushes { get; set; }
        public List<Spawn> Spawns { get; set; }
        public List<ItemBase> Items { get; set; }
        public List<Team> Teams { get; set; }
        public Player CurrentPlayer { get; set; }
        public GameEngine()
        {
            Bushes = new List<Bush>();
            Spawns = new List<Spawn>();
            Items = new List<ItemBase>();
            Teams = new List<Team>();
        }
        static void Main(string[] args)
        {
            GameEngine game = new GameEngine();
            game.Initialize();
            game.Start();
        }
        public void Initialize()
        {
            int currentPlayerTeamId;
            string[] inputs;
            if (int.TryParse(Console.ReadLine(), out currentPlayerTeamId))
            {
                CurrentPlayer = new Player(currentPlayerTeamId);
            }
            int bushAndSpawnPointCount = int.Parse(Console.ReadLine()); // useful from wood1, represents the number of bushes and the number of places where neutral units can spawn
            for (int i = 0; i < bushAndSpawnPointCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                var interactiveObject = InteractiveObjectFactory.ParseInteractiveObject(inputs);
                if(interactiveObject != null)
                {
                    if (interactiveObject is Bush)
                        Bushes.Add(interactiveObject as Bush);
                    else if (interactiveObject is Spawn)
                        Spawns.Add(interactiveObject as Spawn);
                }
            }
            int itemCount = int.Parse(Console.ReadLine()); // useful from wood2
            for (int i = 0; i < itemCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                var item = ItemFactory.ParseItem(inputs);
                if (item != null)
                    Items.Add(item);
            }
            Teams.Add(new Team(currentPlayerTeamId));
            Teams.Add(new Team(currentPlayerTeamId == 0 ? 1 : 0));
            Console.Error.WriteLine(currentPlayerTeamId);
        }
        public void Start()
        {
            string[] inputs;
            this.fightManager.Initialize(CurrentPlayer);
            this.fightManager.AddTeams(Teams);
            this.fightManager.StartFight();
            // game loop
            while (true)
            {
                var currentPlayerTeam = Teams.FirstOrDefault(x => x.Id == CurrentPlayer.TeamId);
                var ennemyTeam = Teams.FirstOrDefault(x => x.Id != CurrentPlayer.TeamId);
                int gold, enemyGold;
                if(int.TryParse(Console.ReadLine(), out gold))
                    currentPlayerTeam.Gold = gold;
                if (int.TryParse(Console.ReadLine(), out enemyGold))
                    ennemyTeam.Gold = enemyGold;
                int roundType = int.Parse(Console.ReadLine()); // a positive value will show the number of heroes that await a command
                int entityCount = int.Parse(Console.ReadLine());
                for (int i = 0; i < entityCount; i++)
                {
                    inputs = Console.ReadLine().Split(' ');
                    int teamId = int.Parse(inputs[1]);
                    var entity = EntityFactory.ParseEntity(inputs);
                    // TODO: add method ? observer ?
                    Teams.FirstOrDefault(x => x.Id == teamId).Entities.Add(entity);
                }
                // Write an action using Console.WriteLine()
                // To debug: Console.Error.WriteLine("Debug messages...");
                this.fightManager.NextTurn();
                // If roundType has a negative value then you need to output a Hero name, such as "DEADPOOL" or "VALKYRIE".
                // Else you need to output roundType number of any valid action, such as "WAIT" or "ATTACK unitId"
                //Console.WriteLine("WAIT");
                Console.WriteLine(this.fightManager.RenderOutput());
            }
        }
    }
}
namespace Core
{
    class GameSettings
    {
        //LEAGUE
        // wood3 = 0;
        // wood2 = 1;
        // wood1 = 2;
        // bronze and above = 3+;
        public const bool RemoveForestCreatures = false;
        public const bool IgnoreItems = false;
        public const bool IgnoreSkills = false;
        public const double TowerHealthScale = 1.0;
        public const bool IgnoreBushes = false;
        //MISC
        public const double Epsilon = 0.00001;
        public const double RoundTime = 1.0;
        public const int Rounds = 250;
        public const int MapWidth = 1920;
        public const int MapHeight = 780;
        public const int HeroCount = 2;
        public const int MaxItemCount = 4;
        public const int MeleeUnitCount = 3;
        public const int RangedUnitCount = 1;
        public const double SellItemRefund = 0.5;
        //TEAM A
        public static readonly Point TowerTeamA = new Point(100, 540);
        public static readonly Point SpawnTeamA = new Point(TowerTeamA.X + 60, TowerTeamA.Y - 50);
        public static readonly Point HeroSpawnTeamA = new Point(TowerTeamA.X + 100, TowerTeamA.Y + 50);
        //public static readonly Point HeroSpawnTeamAHero2 = new Point(HeroSpawnTeamA.X, HeroSpawnTeamA.Y - 50); TODO: dynamically
        //TEAM B
        public static readonly Point TowerTeamB = new Point(MapWidth - TowerTeamA.X, TowerTeamA.Y);
        public static readonly Point SpawnTeamB = new Point(MapWidth - SpawnTeamA.X, SpawnTeamA.Y);
        public static readonly Point HeroSpawnTeamB = new Point(MapWidth - HeroSpawnTeamA.X, HeroSpawnTeamA.Y);
        //public static readonly Point HEROSPAWNTEAM1HERO2 = new Point(HEROSPAWNTEAM1.x, HEROSPAWNTEAM0HERO2.y);
        //HERO
        public const int SkillCount = 3;
        public const int MaxMoveSpeed = 450;
        //UNIT
        public const int SpawnRate = 15;
        public const int UnitTargetDistance = 400;
        public const int UnitTargetDistance2 = UnitTargetDistance * UnitTargetDistance;
        public const int AggroUnitRange = 300;
        public const int AggroUnitRange2 = AggroUnitRange * AggroUnitRange;
        public const int AggroUnitTime = 3;
        public const double DenyHealth = 0.4;
        public const double BushRadius = 50;
        //TOWERS
        public const int TowerHealth = 3000;
        //NEUTRAL CREEP
        public const int NeutralSpawnTime = 4;
        public const int NeutralSpawnRate = 40;
        public const int NeutralGold = 100;
        public const int NeutralAggroRange = 600;
        /// SPELLS
        /// 
        // KNIGHT
        public const double ExplosiveShieldRange2 = 151 * 151;
        public const int ExplosiveShieldDamage = 50;
        // DOCTOR STRANGE
        public const double RepelRadius = 150;
        public const double RepelPushDistance = 200;
        // LANCER
        public const int PowerUpMoveSpeed = 0;
        public const double PowerUpDamageIncrease = 0.3;
        public const int PowerUpRange = 10;
        //GOLD UNIT VALUES
        public const int StartingGoldValue = 0;
        public const int MeleeUnitGoldValue = 30;
        public const int RangerUnitGoldValue = 50;
        public const int HeroGoldValue = 300;
        public const int GlobalId = 1;
    }
}
namespace Core.Actors
{
    public class Creep : Entity
    {
        public Creep()
        {
        }
        public Creep(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue)
        {
        }
    }
}
namespace Core.Actors
{
    public enum EntityType
    {
        UNIT,
        HERO,
        TOWER,
        GROOT,
    }
    public class Entity : EntityBase
    {
        int id;
        int attackRange;
        int health;
        int maxHealth;
        int shield; // useful in bronze
        int attackDamage;
        int movementSpeed;
        int stunDuration; // useful in bronze
        int goldValue;
        /// <summary>
        /// For unboxing
        /// </summary>
        public Entity()
            : base(0, 0)
        {
        }
        public Entity(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue) : base(x, y)
        {
            this.id = id;
            this.attackRange = attackRange;
            this.health = health;
            this.maxHealth = maxHealth;
            this.shield = shield;
            this.attackDamage = attackDamage;
            this.movementSpeed = movementSpeed;
            this.stunDuration = stunDuration;
            this.goldValue = goldValue;
        }
        public int Id { get => id; set => id = value; }
        public int AttackRange { get => attackRange; set => attackRange = value; }
        public int Health { get => health; set => health = value; }
        public int MaxHealth { get => maxHealth; set => maxHealth = value; }
        public int Shield { get => shield; set => shield = value; }
        public int AttackDamage { get => attackDamage; set => attackDamage = value; }
        public int MovementSpeed { get => movementSpeed; set => movementSpeed = value; }
        public int StunDuration { get => stunDuration; set => stunDuration = value; }
        public int GoldValue { get => goldValue; set => goldValue = value; }
    }
}
namespace Core.Actors
{
    public abstract class EntityBase : Point
    {
        public EntityBase(double x, double y)
            : base(x, y)
        {
        }
    }
}
namespace Core.Actors
{
    public class Groot : Entity
    {
        public Groot()
        {
        }
        public Groot(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue)
        {
        }
    }
}
namespace Core.Actors
{
    public enum HeroType
    {
        DEADPOOL,
        VALKYRIE,
        DOCTOR_STRANGE,
        HULK,
        IRONMAN,
    }
    public class Hero : Entity
    {
        HeroType heroType;
        int countDown1; // all countDown and mana variables are useful starting in bronze
        int countDown2;
        int countDown3;
        int mana;
        int maxMana;
        int manaRegeneration;
        int isVisible; // 0 if it isn't
        int itemsOwned; // useful from wood1
        public Hero()
        {
        }
        public Hero(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue,
            int countDown1,
            int countDown2,
            int countDown3,
            int mana,
            int maxMana,
            int manaRegeneration,
            int isVisible,
            int itemsOwned,
            HeroType heroType = HeroType.DEADPOOL
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue
            )
        {
            this.heroType = heroType;
            this.countDown1 = countDown1;
            this.countDown2 = countDown2;
            this.countDown3 = countDown3;
            this.mana = mana;
            this.maxMana = maxMana;
            this.manaRegeneration = manaRegeneration;
            this.isVisible = isVisible;
            this.itemsOwned = itemsOwned;
        }
        public HeroType HeroType { get => heroType; set => heroType = value; }
        public int CountDown1 { get => countDown1; set => countDown1 = value; }
        public int CountDown2 { get => countDown2; set => countDown2 = value; }
        public int CountDown3 { get => countDown3; set => countDown3 = value; }
        public int Mana { get => mana; set => mana = value; }
        public int MaxMana { get => maxMana; set => maxMana = value; }
        public int ManaRegeneration { get => manaRegeneration; set => manaRegeneration = value; }
        public int IsVisible { get => isVisible; set => isVisible = value; }
        public int ItemsOwned { get => itemsOwned; set => itemsOwned = value; }
        public IArtificialIntelligence IA { get; set; }
    }
}
namespace Core.Actors
{
    public class Player
    {
        int teamId;
        public Player(int teamId)
        {
            this.teamId = teamId;
        }
        public int TeamId { get => teamId; set => teamId = value; }
    }
}
namespace Core.Actors
{
    public class Tower : Entity
    {
        public Tower()
        {
        }
        public Tower(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue)
        {
        }
    }
}
namespace Core.Factories
{
    public static class EntityFactory
    {
        public static Entity ParseEntity(string[] inputs)
        {
            EntityType entityType;
            Entity entity = null;
            int unitId = int.Parse(inputs[0]);
            int x = int.Parse(inputs[3]);
            int y = int.Parse(inputs[4]);
            int attackRange = int.Parse(inputs[5]);
            int health = int.Parse(inputs[6]);
            int maxHealth = int.Parse(inputs[7]);
            int shield = int.Parse(inputs[8]); // useful in bronze
            int attackDamage = int.Parse(inputs[9]);
            int movementSpeed = int.Parse(inputs[10]);
            int stunDuration = int.Parse(inputs[11]); // useful in bronze
            int goldValue = int.Parse(inputs[12]);
            int countDown1 = int.Parse(inputs[13]); // all countDown and mana variables are useful starting in bronze
            int countDown2 = int.Parse(inputs[14]);
            int countDown3 = int.Parse(inputs[15]);
            int mana = int.Parse(inputs[16]);
            int maxMana = int.Parse(inputs[17]);
            int manaRegeneration = int.Parse(inputs[18]);
            int isVisible = int.Parse(inputs[20]); // 0 if it isn't
            int itemsOwned = int.Parse(inputs[21]); // useful from wood1
            entity = new Entity(
                x,
                y,
                unitId,
                attackRange,
                health,
                maxHealth,
                shield,
                attackDamage,
                movementSpeed,
                stunDuration,
                goldValue);
            string unitType = inputs[2]; // UNIT, HERO, TOWER, can also be GROOT from wood1
            if(Enum.TryParse(unitType, out entityType))
            {
                switch (entityType)
                {
                    case EntityType.UNIT:
                        entity = UnBoxingHelper.ToDerived<Entity, Creep>(entity);
                        break;
                    case EntityType.HERO:
                        HeroType heroType;
                        string tmpHeroType = inputs[19]; // DEADPOOL, VALKYRIE, DOCTOR_STRANGE, HULK, IRONMAN
                        if(Enum.TryParse(tmpHeroType, out heroType))
                        {
                            entity = UnBoxingHelper.ToDerived<Entity, Hero>(entity);
                            (entity as Hero).HeroType = heroType;
                        }
                        break;
                    case EntityType.TOWER:
                        entity = UnBoxingHelper.ToDerived<Entity, Tower>(entity);
                        break;
                    case EntityType.GROOT:
                        entity = UnBoxingHelper.ToDerived<Entity, Groot>(entity);
                        break;
                }
            }
            return entity;
        }
    }
}
namespace Core.Factories
{
    public static class InteractiveObjectFactory
    {
        public enum InteractiveObjectType
        {
            NONE,
            BUSH,
            SPAWN,
        }
        public static EntityBase ParseInteractiveObject(string[] inputs)
        {
            EntityBase entity = null;
            InteractiveObjectType interactiveType = InteractiveObjectType.NONE;
            string entityType = inputs[0]; // BUSH, from wood1 it can also be SPAWN
            int x = int.Parse(inputs[1]);
            int y = int.Parse(inputs[2]);
            int radius = int.Parse(inputs[3]);
            if(Enum.TryParse(entityType, out interactiveType))
            {
                switch(interactiveType)
                {
                    case InteractiveObjectType.BUSH:
                        entity = new Bush(x, y, radius);
                        break;
                    case InteractiveObjectType.SPAWN:
                        entity = new Spawn(x, y);
                        break;
                }
            }
            return entity;
        }
    }
}
namespace Core.Factories
{
    public static class ItemFactory
    {
        public static ItemBase ParseItem(string[] inputs)
        {
            ItemBase itemBase;
            string itemName = inputs[0]; // contains keywords such as BRONZE, SILVER and BLADE, BOOTS connected by "_" to help you sort easier
            int itemCost = int.Parse(inputs[1]); // BRONZE items have lowest cost, the most expensive items are LEGENDARY
            int damage = int.Parse(inputs[2]); // keyword BLADE is present if the most important item stat is damage
            int health = int.Parse(inputs[3]);
            int maxHealth = int.Parse(inputs[4]);
            int mana = int.Parse(inputs[5]);
            int maxMana = int.Parse(inputs[6]);
            int moveSpeed = int.Parse(inputs[7]); // keyword BOOTS is present if the most important item stat is moveSpeed
            int manaRegeneration = int.Parse(inputs[8]);
            int isPotion = int.Parse(inputs[9]); // 0 if it's not instantly consumed
            if (isPotion == 0)
                itemBase = new Item(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration);
            else
                itemBase = new Consumable(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration);
            return itemBase;
        }
    }
}
namespace Core.Fights
{
    public enum FightPhase
    {
        NONE,
        PLACEMENT,
        FIGHTING,
        ENDED
    }
    public class Fight
    {
        StringBuilder output;
        public Player CurrentPlayer { get; set; }
        public FightPhase FightPhase { get; set; }
        public List<Team> Teams { get; set; }
        public IArtificialIntelligence BasicIA = new Rush();
        public Fight(ref StringBuilder output)
        {
            this.output = output;
            Teams = new List<Team>();
        }
        public void Initialize(Player currentPlayer)
        {
            CurrentPlayer = currentPlayer;
            FightPhase = FightPhase.PLACEMENT;
        }
        public void AddTeam(Team team)
        {
            if(FightPhase == FightPhase.PLACEMENT && !Teams.Any(x => x.Id == team.Id))
                Teams.Add(team);
        }
        public void Start()
        {
            if (FightPhase == FightPhase.PLACEMENT)
            {
                this.output.AppendLine(HeroType.DEADPOOL.ToString());
                FightPhase = FightPhase.FIGHTING;
            }
        }
        public void Next()
        {
            var currentTeam = Teams.FirstOrDefault(x => x.Id == CurrentPlayer.TeamId);
            currentTeam.Entities.Where(x => x is Hero).Cast<Hero>().ToList().ForEach(hero => {
                if (hero.IA != null)
                    this.output.AppendLine(hero.IA.ComputeAction(currentTeam, Teams.FirstOrDefault(x => x.Id != CurrentPlayer.TeamId)));
                else
                    this.output.AppendLine(BasicIA.ComputeAction(currentTeam, Teams.FirstOrDefault(x => x.Id != CurrentPlayer.TeamId)));
            });
        }
    }
}
namespace Core.Fights
{
    public class FightManager
    {
        StringBuilder output;
        Fight fight;
        public FightManager()
        {
            output = new StringBuilder();
            this.fight = new Fight(ref this.output);
        }
        public void Initialize (Player player) => this.fight.Initialize(player);
        public void AddTeams(List<Team> teams) => teams.ForEach(x => this.fight.AddTeam(x));
        public void StartFight() => this.fight.Start();
        public void NextTurn()
        {
            output.Clear();
            this.fight.Next();
        }
        public string RenderOutput()
        {
            var outputResult = output.ToString();
            return outputResult != "" ? outputResult : "WAIT";
        }
    }
}
namespace Core.Fights
{
    public class Team
    {
        int id;
        int gold;
        List<EntityBase> entities;
        public Team(int id, int gold = GameSettings.StartingGoldValue)
        {
            this.id = id;
            this.gold = gold;
            this.entities = new List<EntityBase>();
        }
        public int Id { get => this.id; set => this.id = value; }
        public int Gold { get => this.gold; set => this.gold = value; }
        public List<EntityBase> Entities { get => this.entities; set => this.entities = value; }
    }
}
namespace Core.IA
{
    public interface IArtificialIntelligence
    {
        string ComputeAction(Team currentTeam, Team ennemyTeam);
    }
}
namespace Core.IA
{
    public class Rush : IArtificialIntelligence
    {
        public string ComputeAction(Team currentTeam, Team ennemyTeam)
        {
            var target = ennemyTeam.Entities.FirstOrDefault(x => x is Tower) as Tower;
            return $"MOVE_ATTACK {target.X} {target.Y} {target.Id}";            
        }
    }
}
namespace Core.Interactives
{
    public class Bush : EntityBase
    {
        int radius;
        public Bush(double x, double y, int radius) 
            : base(x, y)
        {
            this.radius = radius;
        }
    }
}
namespace Core.Interactives
{
    public class Spawn : EntityBase
    {
        public Spawn(double x, double y) 
            : base(x, y)
        {
        }
    }
}
namespace Core.Items
{
    public class Consumable : ItemBase
    {
        public Consumable(string itemName, int itemCost, int damage, int health, int maxHealth, int mana, int maxMana, int moveSpeed, int manaRegeneration) 
            : base(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration)
        {
        }
    }
}
namespace Core.Items
{
    public class Item : ItemBase
    {
        public Item(string itemName, int itemCost, int damage, int health, int maxHealth, int mana, int maxMana, int moveSpeed, int manaRegeneration) 
            : base(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration)
        {
        }
    }
}
namespace Core.Items
{
    public class ItemBase
    {
        string itemName; // contains keywords such as BRONZE, SILVER and BLADE, BOOTS connected by "_" to help you sort easier
        int itemCost; // BRONZE items have lowest cost, the most expensive items are LEGENDARY
        int damage; // keyword BLADE is present if the most important item stat is damage
        int health;
        int maxHealth;
        int mana;
        int maxMana;
        int moveSpeed; // keyword BOOTS is present if the most important item stat is moveSpeed
        int manaRegeneration;
        public ItemBase(string itemName, int itemCost, int damage, int health, int maxHealth, int mana, int maxMana, int moveSpeed, int manaRegeneration)
        {
            this.itemName = itemName;
            this.itemCost = itemCost;
            this.damage = damage;
            this.health = health;
            this.maxHealth = maxHealth;
            this.mana = mana;
            this.maxMana = maxMana;
            this.moveSpeed = moveSpeed;
            this.manaRegeneration = manaRegeneration;
        }
        public string ItemName { get => this.itemName; }
        public int ItemCost { get => this.itemCost; set => this.itemCost = value; }
    }
}
namespace Core.Utils
{
    public class Point
    {
        double x;
        double y;
        public Point(double x, double y)
        {
            this.x = x;
            this.y = y;
        }
        public double Distance(Point p) => Math.Sqrt(this.ComputeDistance(p));
        public double ComputeDistance(Point p) => ((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));
        public bool IsInRange(Point p, double range) => p != this && this.Distance(p) <= range;
        public double X { get => this.x; set => this.x = value; }
        public double Y { get => this.y; set => this.y = value; }
    }
}
namespace Core.Utils
{
    public static class UnBoxingHelper
    {
        public static TDerived ToDerived<TBase, TDerived>(TBase tBase) where TDerived : TBase, new()
        {
            TDerived tDerived = new TDerived();
            foreach (PropertyInfo propBase in typeof(TBase).GetProperties())
            {
                PropertyInfo propDerived = typeof(TDerived).GetProperty(propBase.Name);
                if (propDerived.CanWrite)
                {
                    try
                    {
                        var value = propBase.GetValue(tBase, null);
                        if (value != null)
                            propDerived.SetValue(tDerived, value, null);
                    }
                    catch (Exception)
                    {
                        continue;
                    }
                }
            }
            return tDerived;
        }
        public static void To<S, D>(S src, ref D dest, params KeyValuePair<string, string>[] hook)
        {
            foreach (var property in typeof(D).GetProperties())
            {
                PropertyInfo prop = null;
                var patch = hook.FirstOrDefault(x => x.Key == property.Name).Value;
                if (!string.IsNullOrEmpty(patch))
                    prop = typeof(S).GetProperty(patch);
                else
                    prop = typeof(S).GetProperty(property.Name);
                if (prop != null && property.CanWrite)
                    property.SetValue(dest, Convert.ChangeType(prop.GetValue(src), prop.PropertyType));
            }
        }
        public static D To<S, D>(S src, params KeyValuePair<string, string>[] hook)
        {
            D result = (D)Activator.CreateInstance(typeof(D));
            To<S, D>(src, ref result, hook);
            return result;
        }
        public static void To<S, D>(S src, ref D dest, Dictionary<string, string> map) => To<S, D>(src: src, dest: ref dest, hook: map.Select(x => x).ToArray());
    }
}
