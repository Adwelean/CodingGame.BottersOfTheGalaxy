/*
 * File generated by SourceCombiner using 32 source files.
 * Created On: 06/03/2018 23:06:09
*/
using Core;
using Core.Actors;
using Core.AI;
using Core.AI.Commands;
using Core.Extensions;
using Core.Factories;
using Core.Fights;
using Core.Interactives;
using Core.Items;
using Core.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace Core
{
    public class GameContext
    {
        Team playerTeam;
        Team enemyTeam;
        Hero playerHero;
        List<ItemBase> items;
        CommandBase lastCommand;
        public GameContext(Team playerTeam, Team enemyTeam, Hero playerHero, List<ItemBase> items, CommandBase lastCommand)
        {
            this.playerTeam = playerTeam;
            this.enemyTeam = enemyTeam;
            this.playerHero = playerHero;
            this.items = items;
            this.lastCommand = lastCommand;
        }
        public Team PlayerTeam { get => playerTeam; set => playerTeam = value; }
        public Team EnemyTeam { get => enemyTeam; set => enemyTeam = value; }
        public Hero PlayerHero { get => playerHero; set => playerHero = value; }
        public List<ItemBase> Items { get => items; set => items = value; }
        public CommandBase LastCommand { get => lastCommand; set => lastCommand = value; }
    }
}
namespace Core
{
    public class GameEngine
    {
        Team playerTeam;
        Team ennemyTeam;
        FightManager fightManager = new FightManager();
        public List<Bush> Bushes { get; set; }
        public List<Spawn> Spawns { get; set; }
        public List<ItemBase> Items { get; set; }
        public Player CurrentPlayer { get; set; }
        public Team PlayerTeam { get => this.playerTeam; set => this.playerTeam = value; }
        public Team EnnemyTeam { get => this.ennemyTeam; set => this.ennemyTeam = value; }
        public GameEngine()
        {
            Bushes = new List<Bush>();
            Spawns = new List<Spawn>();
            Items = new List<ItemBase>();
        }
        static void Main(string[] args)
        {
            GameEngine game = new GameEngine();
            game.Initialize();
            game.Start();
        }
        public void Initialize()
        {
            int currentPlayerTeamId;
            string[] inputs;
            if (int.TryParse(Console.ReadLine(), out currentPlayerTeamId))
            {
                CurrentPlayer = new Player(currentPlayerTeamId);
            }
            int bushAndSpawnPointCount = int.Parse(Console.ReadLine()); // useful from wood1, represents the number of bushes and the number of places where neutral units can spawn
            for (int i = 0; i < bushAndSpawnPointCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                var interactiveObject = InteractiveObjectFactory.ParseInteractiveObject(inputs);
                if(interactiveObject != null)
                {
                    if (interactiveObject is Bush)
                        Bushes.Add(interactiveObject as Bush);
                    else if (interactiveObject is Spawn)
                        Spawns.Add(interactiveObject as Spawn);
                }
            }
            int itemCount = int.Parse(Console.ReadLine()); // useful from wood2
            for (int i = 0; i < itemCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                var item = ItemFactory.ParseItem(inputs);
                if (item != null)
                    Items.Add(item);
            }
            PlayerTeam = new Team(currentPlayerTeamId);
            EnnemyTeam = new Team(currentPlayerTeamId == 0 ? 1 : 0);
        }
        public void Start()
        {
            string[] inputs;
            this.fightManager.Initialize(CurrentPlayer, Items);
            this.fightManager.AddTeam(this.playerTeam);
            this.fightManager.AddTeam(this.ennemyTeam);
            this.fightManager.Picking();
            //Console.WriteLine(this.fightManager.RenderOutput());
            // game loop
            while (true)
            {
                try
                {
                    PlayerTeam.Gold = int.Parse(Console.ReadLine());
                    EnnemyTeam.Gold = int.Parse(Console.ReadLine());
                    int roundType = int.Parse(Console.ReadLine()); // a positive value will show the number of heroes that await a command
                    int entityCount = int.Parse(Console.ReadLine());
                    List<KeyValuePair<int, Entity>> newEntities = new List<KeyValuePair<int, Entity>>();
                    for (int i = 0; i < entityCount; i++)
                    {
                        inputs = Console.ReadLine().Split(' ');
                        int teamId = int.Parse(inputs[1]);
                        newEntities.Add(new KeyValuePair<int, Entity>(teamId, EntityFactory.ParseEntity(inputs)));
                    }
                    PlayerTeam.UpdateEntities(newEntities.Where(x => x.Key == PlayerTeam.Id).Select(x => x.Value).ToList());
                    EnnemyTeam.UpdateEntities(newEntities.Where(x => x.Key == EnnemyTeam.Id).Select(x => x.Value).ToList());
                    newEntities.ForEach(entity =>
                    {
                        var team = (PlayerTeam.Id == entity.Key) ? PlayerTeam : EnnemyTeam;
                        if (team.Entities.Any(x => x.Id == entity.Value.Id))
                            team.Entities.FirstOrDefault(x => x.Id == entity.Value.Id).Update(entity.Value);
                        else
                            team.Entities.Add(entity.Value);
                    });
                    // Write an action using Console.WriteLine()
                    // To debug: Console.Error.WriteLine("Debug messages...");
                    this.fightManager.NextTurn();
                    // If roundType has a negative value then you need to output a Hero name, such as "DEADPOOL" or "VALKYRIE".
                    // Else you need to output roundType number of any valid action, such as "WAIT" or "ATTACK unitId"
                    //Console.WriteLine("WAIT");
                    Console.WriteLine(this.fightManager.RenderOutput());
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(ex.InnerException);
                    Console.WriteLine("WAIT");
                }
            }
        }
    }
}
namespace Core
{
    class GameSettings
    {
        //LEAGUE
        // wood3 = 0;
        // wood2 = 1;
        // wood1 = 2;
        // bronze and above = 3+;
        public const bool RemoveForestCreatures = false;
        public const bool IgnoreItems = false;
        public const bool IgnoreSkills = false;
        public const double TowerHealthScale = 1.0;
        public const bool IgnoreBushes = false;
        //MISC
        public const double Epsilon = 0.00001;
        public const double RoundTime = 1.0;
        public const int Rounds = 250;
        public const int MapWidth = 1920;
        public const int MapHeight = 780;
        public const int HeroCount = 2;
        public const int MaxItemCount = 4;
        public const int MeleeUnitCount = 3;
        public const int RangedUnitCount = 1;
        public const double SellItemRefund = 0.5;
        //TEAM A
        public static readonly Point TowerTeamA = new Point(100, 540);
        public static readonly Point SpawnTeamA = new Point(TowerTeamA.X + 60, TowerTeamA.Y - 50);
        public static readonly Point HeroSpawnTeamA = new Point(TowerTeamA.X + 100, TowerTeamA.Y + 50);
        //public static readonly Point HeroSpawnTeamAHero2 = new Point(HeroSpawnTeamA.X, HeroSpawnTeamA.Y - 50); TODO: dynamically
        //TEAM B
        public static readonly Point TowerTeamB = new Point(MapWidth - TowerTeamA.X, TowerTeamA.Y);
        public static readonly Point SpawnTeamB = new Point(MapWidth - SpawnTeamA.X, SpawnTeamA.Y);
        public static readonly Point HeroSpawnTeamB = new Point(MapWidth - HeroSpawnTeamA.X, HeroSpawnTeamA.Y);
        //public static readonly Point HEROSPAWNTEAM1HERO2 = new Point(HEROSPAWNTEAM1.x, HEROSPAWNTEAM0HERO2.y);
        //HERO
        public const int SkillCount = 3;
        public const int MaxMoveSpeed = 450;
        //UNIT
        public const int SpawnRate = 15;
        public const int UnitTargetDistance = 400;
        public const int UnitTargetDistance2 = UnitTargetDistance * UnitTargetDistance;
        public const int AggroUnitRange = 300;
        public const int AggroUnitRange2 = AggroUnitRange * AggroUnitRange;
        public const int AggroUnitTime = 3;
        public const double DenyHealth = 0.4;
        public const double BushRadius = 50;
        //TOWERS
        public const int TowerHealth = 3000;
        //NEUTRAL CREEP
        public const int NeutralSpawnTime = 4;
        public const int NeutralSpawnRate = 40;
        public const int NeutralGold = 100;
        public const int NeutralAggroRange = 600;
        /// SPELLS
        /// 
        // KNIGHT
        public const double ExplosiveShieldRange2 = 151 * 151;
        public const int ExplosiveShieldDamage = 50;
        // DOCTOR STRANGE
        public const double RepelRadius = 150;
        public const double RepelPushDistance = 200;
        // LANCER
        public const int PowerUpMoveSpeed = 0;
        public const double PowerUpDamageIncrease = 0.3;
        public const int PowerUpRange = 10;
        //GOLD UNIT VALUES
        public const int StartingGoldValue = 0;
        public const int MeleeUnitGoldValue = 30;
        public const int RangerUnitGoldValue = 50;
        public const int HeroGoldValue = 300;
        public const int GlobalId = 1;
    }
}
namespace Core.Actors
{
    public class Creep : Entity
    {
        public Creep(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue,
            0)
        {
        }
    }
}
namespace Core.Actors
{
    public enum EntityType
    {
        UNIT,
        HERO,
        TOWER,
        GROOT,
    }
    public class Entity : EntityBase, ICloneable
    {
        int id;
        int attackRange;
        int health;
        int maxHealth;
        int shield; // useful in bronze
        int attackDamage;
        int movementSpeed;
        int stunDuration; // useful in bronze
        int goldValue;
        int itemsOwned;
        List<Item> equipment;
        public Entity(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue,
            int itemsOwned) : base(x, y)
        {
            this.id = id;
            this.attackRange = attackRange;
            this.health = health;
            this.maxHealth = maxHealth;
            this.shield = shield;
            this.attackDamage = attackDamage;
            this.movementSpeed = movementSpeed;
            this.stunDuration = stunDuration;
            this.goldValue = goldValue;
            this.itemsOwned = itemsOwned;
            this.equipment = new List<Item>();
        }
        public void Update(Entity entity)
        {
            base.X = entity.X;
            base.Y = entity.Y;
            this.id = entity.Id;
            this.attackRange = entity.AttackRange;
            this.health = entity.Health;
            this.maxHealth = entity.MaxHealth;
            this.shield = entity.Shield;
            this.attackDamage = entity.AttackDamage;
            this.movementSpeed = entity.MovementSpeed;
            this.stunDuration = entity.StunDuration;
            this.goldValue = entity.GoldValue;
            this.itemsOwned = entity.itemsOwned;
        }
        public object Clone()
        {
            return this.MemberwiseClone();
        }
        public int Id { get => id; set => id = value; }
        public int AttackRange { get => attackRange; set => attackRange = value; }
        public int Health { get => health + Equipment.Sum(x => x.Health); set => health = (value > MaxHealth) ? MaxHealth : value; }
        public int MaxHealth { get => maxHealth + Equipment.Sum(x => x.MaxHealth); set => maxHealth = value; }
        public int Shield { get => shield; set => shield = value; }
        public int AttackDamage { get => attackDamage + Equipment.Sum(x => x.Damage); set => attackDamage = value; }
        public int MovementSpeed { get => movementSpeed + Equipment.Sum(x => x.MoveSpeed); set => movementSpeed = value; }
        public int StunDuration { get => stunDuration; set => stunDuration = value; }
        public int GoldValue { get => goldValue; set => goldValue = value; }
        public int ItemsOwned { get => itemsOwned; set => itemsOwned = value; }
        public List<Item> Equipment { get => equipment; set => equipment = value; }
        public bool IsAlive => Health > 0;
    }
}
namespace Core.Actors
{
    public abstract class EntityBase : Point
    {
        public EntityBase(double x, double y)
            : base(x, y)
        {
        }
        /*public virtual void Update(Entity entity)
        {
            base.X = entity.X;
            base.Y = entity.Y;
        }*/
    }
}
namespace Core.Actors
{
    public class Groot : Entity
    {
        public Groot(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue,
            0)
        {
        }
    }
}
namespace Core.Actors
{
    public enum HeroType
    {
        DEADPOOL,
        VALKYRIE,
        DOCTOR_STRANGE,
        HULK,
        IRONMAN,
    }
    public partial class Hero : Entity
    {
        HeroType heroType;
        int countDown1; // all countDown and mana variables are useful starting in bronze
        int countDown2;
        int countDown3;
        int mana;
        int maxMana;
        int manaRegeneration;
        int isVisible; // 0 if it isn't
        int itemsOwned; // useful from wood1
        public Hero(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue,
            int countDown1,
            int countDown2,
            int countDown3,
            int mana,
            int maxMana,
            int manaRegeneration,
            int isVisible,
            int itemsOwned,
            HeroType heroType
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue,
            itemsOwned)
        {
            this.heroType = heroType;
            this.countDown1 = countDown1;
            this.countDown2 = countDown2;
            this.countDown3 = countDown3;
            this.mana = mana;
            this.maxMana = maxMana;
            this.manaRegeneration = manaRegeneration;
            this.isVisible = isVisible;
        }
        public HeroType HeroType { get => heroType; set => heroType = value; }
        public int CountDown1 { get => countDown1; set => countDown1 = value; }
        public int CountDown2 { get => countDown2; set => countDown2 = value; }
        public int CountDown3 { get => countDown3; set => countDown3 = value; }
        public int Mana { get => mana + Equipment.Sum(x => x.Mana); set => mana = (value > MaxMana) ? MaxMana : value; }
        public int MaxMana { get => maxMana + Equipment.Sum(x => x.MaxMana); set => maxMana = value; }
        public int ManaRegeneration { get => manaRegeneration + Equipment.Sum(x => x.ManaRegeneration); set => manaRegeneration = value; }
        public int IsVisible { get => isVisible; set => isVisible = value; }  
        public IArtificialIntelligence AI { get; set; }
    }
}
namespace Core.Actors
{
    public partial class Hero : Entity
    {
    }
}
namespace Core.Actors
{
    public class Player
    {
        int teamId;
        IArtificialIntelligence ai;
        public Player(int teamId)
        {
            this.teamId = teamId;
            //this.ai = new AI.Rush();
            this.ai = new AI.Basic();
        }
        public HeroType ChooseHero(Team team)
        {
            return HeroType.DEADPOOL;
        }
        public int TeamId { get => teamId; set => teamId = value; }
        public IArtificialIntelligence AI { get => ai; set => ai = value; }
    }
}
namespace Core.Actors
{
    public class Tower : Entity
    {
        public Tower(
            double x,
            double y,
            int id,
            int attackRange,
            int health,
            int maxHealth,
            int shield,
            int attackDamage,
            int movementSpeed,
            int stunDuration,
            int goldValue
        ) : base(
            x,
            y,
            id,
            attackRange,
            health,
            maxHealth,
            shield,
            attackDamage,
            movementSpeed,
            stunDuration,
            goldValue,
            0)
        {
        }
    }
}
namespace Core.AI
{
    public class Basic : IArtificialIntelligence
    {
        public enum State
        {
            Protect,
            Attack,
            TowerAssault
        }
        GameContext context;
        Team PlayerTeam => context.PlayerTeam;
        Team EnemyTeam => context.EnemyTeam;
        Hero PlayerHero => context.PlayerHero;
        CommandBase LastCommand => context.LastCommand;
        List<ItemBase> Items => context.Items;
        int FactorDirection => (PlayerTeam.Id > 0) ? -1 : 1;
        Queue<Item> pendingItemsToSell = new Queue<Item>();
        public CommandBase ComputeAction(GameContext context)
        {
            this.context = context;
            CommandBase action = new Commands.Wait();
            var playerHeroes = PlayerTeam.Entities.Where(x => x is Hero).Cast<Hero>().ToList();
            var playerTower = PlayerTeam.Entities.FirstOrDefault(x => x is Tower) as Tower;
            var enemyHeroes = EnemyTeam.Entities.Where(x => x is Hero).Cast<Hero>().ToList();
            var enemyTower = EnemyTeam.Entities.FirstOrDefault(x => x is Tower) as Tower;
            var playerState = ComputeState(playerTower, PlayerHero, enemyTower, enemyHeroes);
            switch (playerState)
            {
                case State.Attack:
                    action = AttackStrategy(playerTower, enemyTower);
                    break;
                case State.TowerAssault:
                    action = TowerAssaultStrategy(enemyTower);
                    break;
                default:
                    action = ProtectStrategy(playerTower);
                    break;
            }
            return action;
        }
        public State ComputeState(Tower playerTower, Hero playerHero, Tower enemyTower, List<Hero> enemyHeroes)
        {
            if (PlayerTeam.Entities.Count(x => x is Creep) < EnemyTeam.Entities.Count(x => x is Creep) &&
               enemyHeroes.Any(x => playerTower.Distance(x) < GameSettings.MapWidth / 3))
            {
                return State.Protect;
            }
            else if (//PlayerTeam.Entities.Count(x => x is Creep) > EnemyTeam.Entities.Count(x => x is Creep) &&
                     playerHero.Distance(enemyTower) < GameSettings.MapWidth / 4) // TODO: change by playerHero.IsInRange(enemyTower, enemyTower.AttackRange) ?
            {
                return State.TowerAssault;
            }
            else
                return State.Attack;
        }
        public CommandBase ProtectStrategy(Tower playerTower)
        {
            var creepEnemyWithLowHealth = EnemyCreepWithLowHealth;
            if (PlayerHero.Health < PlayerHero.MaxHealth / 2)
            {
                var potion = GetPotion();
                if (potion != null)
                    return PlayerTeam.Buy(potion, PlayerHero);
            }
            // Last Hit
            if (HasEnemyCreepWithLowHealth &&
                creepEnemyWithLowHealth != null &&
                creepEnemyWithLowHealth.IsInRange(PlayerHero, PlayerHero.AttackRange) &&
                creepEnemyWithLowHealth.Health <= PlayerHero.AttackDamage)
            {
                return new Commands.Raw($"ATTACK {creepEnemyWithLowHealth.Id}");
            }
            return new Commands.Move(playerTower.X, playerTower.Y);
        }
        public CommandBase AttackStrategy(Tower playerTower, Tower enemyTower)
        {
            var creepShield = FindPlayerShieldCreep(enemyTower);
            var creepEnemyWithLowHealth = EnemyCreepWithLowHealth;
            var hasEnemyCreepWithLowHealth = HasEnemyCreepWithLowHealth;
            // Back
            if (PlayerTeam.Entities.Where(x => x is Creep).All(x => x.Distance(enemyTower) > PlayerHero.Distance(enemyTower)))
                return new Commands.Move(playerTower.X, playerTower.Y);
            // Heal
            if (PlayerHero.Health < PlayerHero.MaxHealth / 2)
            {
                var potion = Items.Where(x => x is Consumable && x.Health > 0)
                                  .OrderByDescending(x => x.Health)
                                  .FirstOrDefault(x => (x.Health <= PlayerHero.MaxHealth - PlayerHero.Health) &&
                                                       PlayerTeam.CanBuyItem(x, PlayerHero));
                if (potion != null)
                    return new Commands.Raw($"BUY {potion.ItemName}");
                /*else // back
                    return new Commands.Move(PlayerHero.X + (PlayerHero.MovementSpeed * FactorDirection), PlayerHero.Y);*/
            }
            else
            {
                /*if (pendingItemsToSell.Count > 0)
                    return new Commands.Raw($"SELL {pendingItemsToSell.Dequeue().ItemName}");*/
                // Buy blade but reserve 1 slot for potion
                if (PlayerHero.ItemsOwned < GameSettings.MaxItemCount - 1)
                {
                    var damageItemsOrdered = Items.Where(x => x is Item && x.Damage > 0).OrderByDescending(x => x.Damage);
                    var blade = damageItemsOrdered.FirstOrDefault(x => x.ItemName.Contains("Blade") && PlayerTeam.CanBuyItem(x, PlayerHero));
                    if (blade != null)
                    {
                        PlayerTeam.Buy(blade, PlayerHero);
                        return new Commands.Raw($"BUY {blade.ItemName}");
                    }
                    else
                        damageItemsOrdered.FirstOrDefault(x => PlayerTeam.CanBuyItem(x, PlayerHero));
                }
                else
                {
                    /*var groupedItems = PlayerHero.Equipment.GroupBy(x => x.ItemName);
                    var duplicateItems = groupedItems.SelectMany(x => x.Where(y => y.ItemName == x.Max(z => z.ItemName)));
                    if (duplicateItems != null && duplicateItems.Count() > 1)
                    {
                        duplicateItems.ToList().ForEach(item => pendingItemsToSell.Enqueue(item));
                        return new Commands.Raw($"SELL {pendingItemsToSell.Dequeue().ItemName}");
                    }*/
                }
            }
            // Need a cover
            if (LastCommand != null &&
                LastCommand.Build().Contains("ATTACK") &&
                !(hasEnemyCreepWithLowHealth &&
                creepEnemyWithLowHealth != null &&
                creepEnemyWithLowHealth.IsInRange(PlayerHero, PlayerHero.AttackRange) &&
                creepEnemyWithLowHealth.Health <= PlayerHero.AttackDamage))
            {
                if (creepShield != null)
                    return new Commands.Move(creepShield.X, creepShield.Y);
                else
                    return new Commands.Move(playerTower.X, playerTower.Y);
            }
            // Safe
            if (!HasEnemyInRange(PlayerHero) &&
                !HasEnemyInRange(new Point(PlayerHero.X + (PlayerHero.MovementSpeed * FactorDirection), PlayerHero.Y), PlayerHero.AttackRange))
                return new Commands.Move(creepShield.X + ((creepShield.AttackRange / 2) * FactorDirection), creepShield.Y);
            // Last Hit
            if (hasEnemyCreepWithLowHealth &&
                creepEnemyWithLowHealth != null &&
                creepEnemyWithLowHealth.IsInRange(PlayerHero, PlayerHero.AttackRange) &&
                creepEnemyWithLowHealth.Health <= PlayerHero.AttackDamage)
            {
                return new Commands.Raw($"ATTACK {creepEnemyWithLowHealth.Id}");
            }
            // TODO: can be move to the creep and attack ? check ratio < 1
            /*else if (hasEnemyCreepWithLowHealth &&
                     creepEnemyWithLowHealth != null &&
                     creepEnemyWithLowHealth.Health <= PlayerHero.AttackDamage)
            {
                return new Commands.Raw($"MOVE_ATTACK {creepEnemyWithLowHealth.X} {creepEnemyWithLowHealth.Y} {creepEnemyWithLowHealth.Id}");
                //return new Commands.Move(creepShield.X, creepShield.Y);
            }*/
            // Pick Hero
            else if (EnemyTeam.Entities.Where(x => x is Creep).All(x => (x.Distance(enemyTower) + x.MovementSpeed + x.AttackRange) < EnemyTeam.Entities.OrderBy(y => y.Distance(PlayerHero)).FirstOrDefault()?.Distance(enemyTower)))
                return new Commands.Raw($"ATTACK_NEAREST {EntityType.HERO}");
            else
                return new Commands.Raw($"ATTACK_NEAREST {EntityType.UNIT}");
        }
        public CommandBase TowerAssaultStrategy(Tower enemyTower)
        {
            var creepShield = FindPlayerShieldCreep(enemyTower);
            Entity previousCreep;
            var playerCreeps = PlayerTeam.Entities.Where(x => x is Creep && x.IsAlive && x.Id != creepShield.Id);
            if (FactorDirection > 0)
                previousCreep = playerCreeps.OrderByDescending(x => x.X).FirstOrDefault();
            else
                previousCreep = playerCreeps.OrderBy(x => x.X).FirstOrDefault();
            if (previousCreep != null)
                return new Commands.Move(previousCreep.X, previousCreep.Y);
            else
                return new Commands.Move(creepShield.X, creepShield.Y);
        }
        public Creep FindPlayerShieldCreep(Tower tower)
        {
            Creep bestCreep = null;
            PlayerTeam.Entities.Where(x => x is Creep && x.IsAlive).ToList().ForEach(creep =>
            {
                if (bestCreep != null && creep.Distance(tower) < bestCreep.Distance(tower))
                    bestCreep = creep as Creep;
                else if (bestCreep == null)
                    bestCreep = creep as Creep;
            });
            return bestCreep;
        }
        public bool HasEnemyCreepWithLowHealth => EnemyTeam.Entities.Where(x => x is Creep && x.IsAlive).Any(x => x.Health != x.MaxHealth);
        public bool HasEnemyInRange(Hero hero) => EnemyTeam.Entities.Where(x => x is Creep && x.IsAlive).Any(x => x.IsInRange(hero, hero.AttackRange));
        public bool HasEnemyInRange(Point heroPosition, double heroAttackRange) => EnemyTeam.Entities.Where(x => x is Creep && x.IsAlive).Any(x => x.IsInRange(heroPosition, heroAttackRange));
        public Creep PlayerCreepWithLowHealth => PlayerTeam.Entities.Where(x => x is Creep && x.IsAlive).OrderBy(x => x.Health).FirstOrDefault() as Creep;
        public Creep EnemyCreepWithLowHealth => EnemyTeam.Entities.Where(x => x is Creep && x.IsAlive).OrderBy(x => x.Health).FirstOrDefault() as Creep;
        public Consumable GetPotion() {
            Consumable consumable = null;
            var potion = Items.Where(x => x is Consumable && x.Health > 0)
                                .OrderByDescending(x => x.Health)
                                .FirstOrDefault(x => (x.Health <= PlayerHero.MaxHealth - PlayerHero.Health) &&
                                                    PlayerTeam.CanBuyItem(x, PlayerHero));
            if (potion != null)
                consumable = potion as Consumable;
            return consumable;
        }
        public bool IsInRangeOfEnemyHeroes(Creep creep)
        {
            bool isInRange = false;
            EnemyTeam.Entities.Where(x => x is Hero && x.IsAlive).ToList().ForEach(hero =>
            {
                if (creep.IsInRange(hero, hero.AttackRange))
                    isInRange = true;
            });
            return isInRange;
        }
    }
}
namespace Core.AI
{
    public interface IArtificialIntelligence
    {
        CommandBase ComputeAction(GameContext context);
    }
}
namespace Core.AI
{
    public class Rush : IArtificialIntelligence
    {
        public CommandBase ComputeAction(GameContext context)
        {
            var target = context.EnemyTeam.Entities.FirstOrDefault(x => x is Tower) as Tower;
            return new Commands.Raw($"MOVE_ATTACK {target.X} {target.Y} {target.Id}");
        }
    }
}
namespace Core.Extensions
{
    public static class ListExtensions
    {
        public static IEnumerable<T> Except<T, TKey>(this IEnumerable<T> items, IEnumerable<T> other, Func<T, TKey> getKey)
        {
            return from item in items
                   join otherItem in other on getKey(item)
                   equals getKey(otherItem) into tempItems
                   from temp in tempItems.DefaultIfEmpty()
                   where ReferenceEquals(null, temp) || temp.Equals(default(T))
                   select item;
        }
    }
}
namespace Core.Factories
{
    public static class EntityFactory
    {
        public static Entity ParseEntity(string[] inputs)
        {
            EntityType entityType;
            Entity entity = null;
            int unitId = int.Parse(inputs[0]);
            int x = int.Parse(inputs[3]);
            int y = int.Parse(inputs[4]);
            int attackRange = int.Parse(inputs[5]);
            int health = int.Parse(inputs[6]);
            int maxHealth = int.Parse(inputs[7]);
            int shield = int.Parse(inputs[8]); // useful in bronze
            int attackDamage = int.Parse(inputs[9]);
            int movementSpeed = int.Parse(inputs[10]);
            int stunDuration = int.Parse(inputs[11]); // useful in bronze
            int goldValue = int.Parse(inputs[12]);
            int countDown1 = int.Parse(inputs[13]); // all countDown and mana variables are useful starting in bronze
            int countDown2 = int.Parse(inputs[14]);
            int countDown3 = int.Parse(inputs[15]);
            int mana = int.Parse(inputs[16]);
            int maxMana = int.Parse(inputs[17]);
            int manaRegeneration = int.Parse(inputs[18]);
            int isVisible = int.Parse(inputs[20]); // 0 if it isn't
            int itemsOwned = int.Parse(inputs[21]); // useful from wood1
            //entity = new Entity(x, y, unitId, attackRange, health, maxHealth, shield, attackDamage, movementSpeed, stunDuration, goldValue);
            string unitType = inputs[2]; // UNIT, HERO, TOWER, can also be GROOT from wood1
            if(Enum.TryParse(unitType, out entityType))
            {
                switch (entityType)
                {
                    case EntityType.UNIT:
                        //entity = UnBoxingHelper.ToDerived<Entity, Creep>(entity);
                        entity = new Creep(x, y, unitId, attackRange, health, maxHealth, shield, attackDamage, movementSpeed, stunDuration, goldValue);
                        break;
                    case EntityType.HERO:
                        HeroType heroType;
                        string tmpHeroType = inputs[19]; // DEADPOOL, VALKYRIE, DOCTOR_STRANGE, HULK, IRONMAN
                        // TODO: refactoring
                        if(Enum.TryParse(tmpHeroType, out heroType))
                        {
                            /*entity = UnBoxingHelper.ToDerived<Entity, Hero>(entity);
                            (entity as Hero).HeroType = heroType;*/
                            entity = new Hero(x, y, unitId, attackRange, health, maxHealth, shield, attackDamage, movementSpeed, stunDuration, goldValue, countDown1, countDown2, countDown3, mana, maxMana, manaRegeneration, isVisible, itemsOwned, heroType);
                        }
                        break;
                    case EntityType.TOWER:
                        //entity = UnBoxingHelper.ToDerived<Entity, Tower>(entity);
                        entity = new Tower(x, y, unitId, attackRange, health, maxHealth, shield, attackDamage, movementSpeed, stunDuration, goldValue);
                        break;
                    case EntityType.GROOT:
                        //entity = UnBoxingHelper.ToDerived<Entity, Groot>(entity);
                        entity = new Groot(x, y, unitId, attackRange, health, maxHealth, shield, attackDamage, movementSpeed, stunDuration, goldValue);
                        break;
                }
            }
            return entity;
        }
    }
}
namespace Core.Factories
{
    public static class InteractiveObjectFactory
    {
        public enum InteractiveObjectType
        {
            NONE,
            BUSH,
            SPAWN,
        }
        public static EntityBase ParseInteractiveObject(string[] inputs)
        {
            EntityBase entity = null;
            InteractiveObjectType interactiveType = InteractiveObjectType.NONE;
            string entityType = inputs[0]; // BUSH, from wood1 it can also be SPAWN
            int x = int.Parse(inputs[1]);
            int y = int.Parse(inputs[2]);
            int radius = int.Parse(inputs[3]);
            if(Enum.TryParse(entityType, out interactiveType))
            {
                switch(interactiveType)
                {
                    case InteractiveObjectType.BUSH:
                        entity = new Bush(x, y, radius);
                        break;
                    case InteractiveObjectType.SPAWN:
                        entity = new Spawn(x, y);
                        break;
                }
            }
            return entity;
        }
    }
}
namespace Core.Factories
{
    public static class ItemFactory
    {
        public static ItemBase ParseItem(string[] inputs)
        {
            ItemBase itemBase;
            string itemName = inputs[0]; // contains keywords such as BRONZE, SILVER and BLADE, BOOTS connected by "_" to help you sort easier
            int itemCost = int.Parse(inputs[1]); // BRONZE items have lowest cost, the most expensive items are LEGENDARY
            int damage = int.Parse(inputs[2]); // keyword BLADE is present if the most important item stat is damage
            int health = int.Parse(inputs[3]);
            int maxHealth = int.Parse(inputs[4]);
            int mana = int.Parse(inputs[5]);
            int maxMana = int.Parse(inputs[6]);
            int moveSpeed = int.Parse(inputs[7]); // keyword BOOTS is present if the most important item stat is moveSpeed
            int manaRegeneration = int.Parse(inputs[8]);
            int isPotion = int.Parse(inputs[9]); // 0 if it's not instantly consumed
            if (isPotion == 0)
                itemBase = new Item(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration);
            else
                itemBase = new Consumable(itemName, itemCost, health, mana, moveSpeed, manaRegeneration);
            return itemBase;
        }
    }
}
namespace Core.Fights
{
    public enum FightPhase
    {
        NONE,
        PLACEMENT,
        FIGHTING,
        ENDED
    }
    public class Fight
    {
        List<string> output = new List<string>();
        Team playerTeam;
        Team enemyTeam;
        public Player CurrentPlayer { get; set; }
        public FightPhase FightPhase { get; set; }
        public Team PlayerTeam { get => playerTeam; set => playerTeam = value; }
        public Team EnemyTeam { get => enemyTeam; set => enemyTeam = value; }
        public IArtificialIntelligence CurrentAI { get; set; }
        public CommandBase LastCommand { get; set; }
        public List<ItemBase> Items { get; set; }
        public Fight()
        {
        }
        public void Initialize(Player currentPlayer, List<ItemBase> items)
        {
            CurrentPlayer = currentPlayer;
            Items = items;
            CurrentAI = currentPlayer.AI;
            FightPhase = FightPhase.PLACEMENT;
        }
        public void AddTeam(Team team)
        {
            if (team.Id == CurrentPlayer.TeamId)
                PlayerTeam = team;
            else
                EnemyTeam = team;
        }
        public void PickingPhase()
        {
            if (FightPhase == FightPhase.PLACEMENT)
            {
                this.output.Add(CurrentPlayer.ChooseHero(EnemyTeam).ToString());
                FightPhase = FightPhase.FIGHTING;
            }
        }
        public void NextTurn()
        {
            PlayerTeam.Entities.Where(x => x is Hero).Cast<Hero>().ToList().ForEach(hero => {
                if (hero.AI != null)
                    LastCommand = hero.AI.ComputeAction(new GameContext(this.playerTeam, this.enemyTeam, hero, Items, LastCommand));
                else
                    LastCommand = CurrentAI.ComputeAction(new GameContext(this.playerTeam, this.enemyTeam, hero, Items, LastCommand));
                this.output.Add(LastCommand.Build());
            });
        }
        public string BuildOutput()
        {
            var outputResult = string.Concat(output);
            output.Clear();
            return outputResult;
        }
    }
}
namespace Core.Fights
{
    public class FightManager
    {
        Fight fight;
        public FightManager()
        {
            this.fight = new Fight();
        }
        public void Initialize (Player player, List<ItemBase> items) => this.fight.Initialize(player, items);
        public void AddTeam(Team team) => this.fight.AddTeam(team);
        public void Picking() => this.fight.PickingPhase();
        public void NextTurn()
        {
            this.fight.NextTurn();
        }
        public string RenderOutput()
        {
            var outputResult = this.fight.BuildOutput();
            return !string.IsNullOrEmpty(outputResult) ? outputResult : "WAIT";
        }
    }
}
namespace Core.Fights
{
    public partial class Team
    {
        int id;
        int gold;
        List<Entity> entities, lastEntities;
        public Team(int id, int gold = GameSettings.StartingGoldValue)
        {
            this.id = id;
            this.gold = gold;
            this.entities = new List<Entity>();
            this.lastEntities = new List<Entity>();
        }
        public int Id { get => this.id; set => this.id = value; }
        public int Gold { get => this.gold; set => this.gold = value; }
        public List<Entity> Entities { get => this.entities; set => this.entities = value; }
        public List<Entity> LastEntities { get => lastEntities; set => lastEntities = value; }
    }
}
namespace Core.Fights
{
    public partial class Team
    {
        public void UpdateEntities(List<Entity> newEntities)
        {
            if (Entities.Count > 0)
                LastEntities = Entities.ConvertAll(x => (Entity)x.Clone());
            Entities.Except(newEntities, x => x.Id).ToList().ForEach(x => Entities.Remove(x));
        }
        public bool CanBuyItem(ItemBase item, Hero hero) => item.ItemCost <= Gold && hero.ItemsOwned < GameSettings.MaxItemCount;
        public CommandBase Buy(ItemBase item, Hero hero)
        {
            if (CanBuyItem(item, hero))
            {
                if (item is Consumable)
                {
                    hero.Health += item.Health;
                    hero.Mana += item.Mana;
                    hero.AttackDamage += item.Damage;
                    hero.MovementSpeed += item.MoveSpeed;
                }
                else
                    Entities.FirstOrDefault(x => x.Id == hero.Id).Equipment.Add(item as Item);
                Gold -= item.ItemCost;
            }
            return new AI.Commands.Raw($"BUY {item.ItemName}");
        }
        public void Sell(ItemBase item, Hero hero)
        {
            hero.Health -= item.Health;
            hero.Mana -= item.Mana;
            hero.AttackDamage -= item.Damage;
            hero.MovementSpeed -= item.MoveSpeed;
            hero.ManaRegeneration -= item.ManaRegeneration;
            hero.MaxHealth -= item.MaxHealth;
            hero.MaxMana -= item.MaxMana;
            Gold += item.ItemCost / 2;
        }
    }
}
namespace Core.Interactives
{
    public class Bush : EntityBase
    {
        int radius;
        public Bush(double x, double y, int radius) 
            : base(x, y)
        {
            this.radius = radius;
        }
    }
}
namespace Core.Interactives
{
    public class Spawn : EntityBase
    {
        public Spawn(double x, double y) 
            : base(x, y)
        {
        }
    }
}
namespace Core.Items
{
    public class Consumable : ItemBase
    {
        public Consumable(string itemName, int itemCost, int health, int mana, int moveSpeed, int manaRegeneration) 
            : base(itemName, itemCost, 0, health, 0, mana, 0, moveSpeed, manaRegeneration)
        {
        }
    }
}
namespace Core.Items
{
    public class Item : ItemBase
    {
        public Item(string itemName, int itemCost, int damage, int health, int maxHealth, int mana, int maxMana, int moveSpeed, int manaRegeneration) 
            : base(itemName, itemCost, damage, health, maxHealth, mana, maxMana, moveSpeed, manaRegeneration)
        {
        }
    }
}
namespace Core.Items
{
    public abstract class ItemBase
    {
        string itemName; // contains keywords such as BRONZE, SILVER and BLADE, BOOTS connected by "_" to help you sort easier
        int itemCost; // BRONZE items have lowest cost, the most expensive items are LEGENDARY
        int damage; // keyword BLADE is present if the most important item stat is damage
        int health;
        int maxHealth;
        int mana;
        int maxMana;
        int moveSpeed; // keyword BOOTS is present if the most important item stat is moveSpeed
        int manaRegeneration;
        public ItemBase(string itemName, int itemCost, int damage, int health, int maxHealth, int mana, int maxMana, int moveSpeed, int manaRegeneration)
        {
            this.itemName = itemName;
            this.itemCost = itemCost;
            this.damage = damage;
            this.health = health;
            this.maxHealth = maxHealth;
            this.mana = mana;
            this.maxMana = maxMana;
            this.moveSpeed = moveSpeed;
            this.manaRegeneration = manaRegeneration;
        }
        public string ItemName { get => itemName; set => itemName = value; }
        public int ItemCost { get => itemCost; set => itemCost = value; }
        public int Damage { get => damage; set => damage = value; }
        public int Health { get => health; set => health = value; }
        public int MaxHealth { get => maxHealth; set => maxHealth = value; }
        public int Mana { get => mana; set => mana = value; }
        public int MaxMana { get => maxMana; set => maxMana = value; }
        public int MoveSpeed { get => moveSpeed; set => moveSpeed = value; }
        public int ManaRegeneration { get => manaRegeneration; set => manaRegeneration = value; }
        public override string ToString()
        {
            return $"ItemName: {ItemName}\n" +
                   $"ItemCost: {ItemCost}\n" +
                   $"Damage: {Damage}"
                   /*$"Health: {Health}\n" +
                   $"Mana: {Mana}\n" +
                   $"MaxHealth: {MaxHealth}\n" +
                   $"MaxMana: {MaxMana}\n"*/;
        }
    }
}
namespace Core.Utils
{
    public class Point
    {
        double x;
        double y;
        public Point(double x, double y)
        {
            this.x = x;
            this.y = y;
        }
        public double Distance(Point p) => Math.Sqrt(this.ComputeDistance(p));
        public double ComputeDistance(Point p) => ((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));
        public bool IsInRange(Point p, double range) => p != this && this.Distance(p) <= range;
        public double X { get => this.x; set => this.x = value; }
        public double Y { get => this.y; set => this.y = value; }
    }
}
namespace Core.AI.Commands
{
    public abstract class CommandBase
    {
        string name;
        public CommandBase(string name)
        {
            this.name = name;
        }
        public string Name { get => name; set => name = value; }
        public abstract string Build();
    }
}
namespace Core.AI.Commands
{
    public class Move : CommandBase
    {
        double x;
        double y;
        public Move(double x, double y)
            : base("MOVE")
        {
            this.x = x;
            this.y = y;
        }
        public override string Build() => $"MOVE {x} {y}";
    }
}
namespace Core.AI.Commands
{
    public class Raw : CommandBase
    {
        public Raw(string command)
            : base(command)
        {
        }
        public override string Build() => Name;
    }
}
namespace Core.AI.Commands
{
    public class Wait : CommandBase
    {
        public Wait()
            : base("WAIT")
        {
        }
        public override string Build() => this.Name;
    }
}
